package it.unibz.krdb.obda.owlrefplatform.core.basicoperations;

import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import it.unibz.krdb.obda.model.CQIE;
import it.unibz.krdb.obda.model.Function;
import it.unibz.krdb.obda.model.OBDADataFactory;
import it.unibz.krdb.obda.model.Predicate;
import it.unibz.krdb.obda.model.impl.OBDADataFactoryImpl;

public class CQContainmentCheckUnderLIDs implements CQContainmentCheck {

	private final OBDADataFactory fac = OBDADataFactoryImpl.getInstance();
	
	private final Map<CQIE,IndexedCQ> indexedCQcache = new HashMap<>();
	
	private final LinearInclusionDependencies dependencies;
	
	/***
	 * Constructs a CQC utility using the given query. If Sigma is not null and
	 * not empty, then it will also be used to verify containment w.r.t.\ Sigma.
	 *
	 */
	public CQContainmentCheckUnderLIDs() {
		dependencies = null;
	}

	/**
	 * *@param sigma
	 * A set of ABox dependencies
	 */
	public CQContainmentCheckUnderLIDs(LinearInclusionDependencies dependencies) {
		this.dependencies = dependencies;
	}
	
	
	/**
	 * This method is used to chase foreign key constraint rule in which the rule
	 * has only one atom in the body.
	 * 
	 * IMPORTANT: each rule is applied only ONCE to each atom
	 * 
	 * @param atoms
	 * @return set of atoms
	 */
	private Set<Function> chaseAtoms(Collection<Function> atoms) {

		Set<Function> derivedAtoms = new HashSet<>();
		for (Function fact : atoms) {
			derivedAtoms.add(fact);
			for (CQIE rule : dependencies.getRules(fact.getFunctionSymbol())) {
				rule = fac.getFreshCQIECopy(rule);
				Function ruleBody = rule.getBody().get(0);
				Substitution theta = UnifierUtilities.getMGU(ruleBody, fact);
				if (theta != null && !theta.isEmpty()) {
					Function ruleHead = rule.getHead();
					Function newFact = (Function)ruleHead.clone();
					// unify to get fact is needed because the dependencies are not necessarily full
					// (in other words, they may contain existentials in the head)
					SubstitutionUtilities.applySubstitution(newFact, theta); 
					derivedAtoms.add(newFact);
				}
			}
		}
		return derivedAtoms;
	}
	
	public static final class IndexedCQ {
		
		private final Function head;
		/***
		 * An index of all the facts obtained by freezing this query.
		 */
		private final Map<Predicate, List<Function>> factMap;
		
		/***
		 * Computes a query in which all terms have been replaced by
		 * ValueConstants that have the no type and have the same 'name' as the
		 * original variable.
		 * 
		 * This new query can be used for query containment checking.
		 * 
		 */
		
		public IndexedCQ(Function head, Collection<Function> body) { 
			
			this.head = head;

			this.factMap = new HashMap<>(body.size() * 2);
			for (Function atom : body) 
				// not boolean, not algebra, not arithmetic, not datatype
				if (atom != null && atom.isDataFunction()) {
					Predicate pred = atom.getFunctionSymbol();
					List<Function> facts = factMap.get(pred);
					if (facts == null) {
						facts = new LinkedList<Function>();
						factMap.put(pred, facts);
					}
					facts.add(atom);
				}
		}
		
		private Substitution computeHomomorphism(CQIE query) {
			SubstitutionBuilder sb = new  SubstitutionBuilder();

			// get the substitution for the head first 
			// it will ensure that all answer variables are mapped either to constants or
			//       to answer variables in the base (but not to the labelled nulls generated by the chase)
			boolean headResult = HomomorphismUtilities.extendHomomorphism(sb, query.getHead(), head);
			if (!headResult)
				return null;
			
			Substitution sub = HomomorphismUtilities.computeHomomorphism(sb, query.getBody(), factMap);
			
			return sub;
		}	
	}

	
	/***
	 * True if the first query is contained in the second query
	 *    (in other words, the first query is more specific, it has fewer answers)
	 * 
	 * @param q1
	 * @param q2
	 * @return true if the first query is contained in the second query
	 */
	@Override	
	public boolean isContainedIn(CQIE q1, CQIE q2) {

		if (!q2.getHead().getFunctionSymbol().equals(q1.getHead().getFunctionSymbol()))
			return false;
		
		return (computeHomomorphsim(q1, q2) != null);
	}
	
	@Override
	public Substitution computeHomomorphsim(CQIE q1, CQIE q2) {

        IndexedCQ indexedQ1 = indexedCQcache.get(q1);
        if (indexedQ1 == null) {
        	Collection<Function> q1body = q1.getBody();
        	if (dependencies != null)
        		q1body = chaseAtoms(q1body);
        	
        	indexedQ1 = new IndexedCQ(q1.getHead(), q1body);
    		indexedCQcache.put(q1, indexedQ1);
        }
           
        // just to speed up the check in case there can be no match
        for (Function q2atom : q2.getBody()) 
			if (!indexedQ1.factMap.containsKey(q2atom.getFunctionSymbol())) { 
				// in particular, !q2atom.isDataFunction() 
				return null;
			}
				
		return indexedQ1.computeHomomorphism(q2);
	}	

/*	
	public CQIE removeRedundantAtoms(CQIE query) {
		List<Function> nonRedundantAtoms = new ArrayList<>(query.getBody().size());
		
		Set<Variable> filterVariables = new HashSet<>();
		for (Function atom : query.getBody())
			if (!atom.isDataFunction())
				filterVariables.addAll(atom.getVariables());
		
		for (Function atom : query.getBody()) {
			if (atom.isDataFunction()) {
				boolean variableOccurrence = false;
				for (Variable term : atom.getVariables()) 
					if (filterVariables.contains(term)) {
						variableOccurrence = true;
						break;
					}
				if (variableOccurrence) {
					nonRedundantAtoms.add(atom);
					continue;
				}
					
				CQIE clone = query.clone();
				clone.getBody().remove(atom);
				if (!isContainedIn(clone, query))
					nonRedundantAtoms.add(atom);
				else
					System.err.println("CQC REMOVED ATOM: " + atom + " FROM " + query);
			}
			else
				nonRedundantAtoms.add(atom);
		}
		
		return fac.getCQIE(query.getHead(), nonRedundantAtoms);
	}
*/
	
	@Override
	public String toString() {
		if (dependencies != null)
			return dependencies.toString();
		
		return "(empty)";
	}
}
