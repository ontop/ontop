package it.unibz.inf.ontop.answering.reformulation.input.translation.impl;

import com.google.common.collect.*;
import com.google.inject.Inject;
import it.unibz.inf.ontop.answering.reformulation.input.translation.RDF4JInputQueryTranslator;
import it.unibz.inf.ontop.exception.OntopInternalBugException;
import it.unibz.inf.ontop.exception.OntopInvalidInputQueryException;
import it.unibz.inf.ontop.exception.OntopUnsupportedInputQueryException;
import it.unibz.inf.ontop.injection.IntermediateQueryFactory;
import it.unibz.inf.ontop.iq.IQ;
import it.unibz.inf.ontop.iq.IQTree;
import it.unibz.inf.ontop.iq.UnaryIQTree;
import it.unibz.inf.ontop.iq.node.*;
import it.unibz.inf.ontop.model.atom.AtomFactory;
import it.unibz.inf.ontop.model.term.*;
import it.unibz.inf.ontop.model.term.functionsymbol.FunctionSymbolFactory;
import it.unibz.inf.ontop.model.term.functionsymbol.LangSPARQLFunctionSymbol;
import it.unibz.inf.ontop.model.term.functionsymbol.SPARQLFunctionSymbol;
import it.unibz.inf.ontop.model.type.RDFDatatype;
import it.unibz.inf.ontop.model.type.TermTypeInference;
import it.unibz.inf.ontop.model.type.TypeFactory;
import it.unibz.inf.ontop.model.vocabulary.SPARQL;
import it.unibz.inf.ontop.model.vocabulary.XPathFunction;
import it.unibz.inf.ontop.model.vocabulary.XSD;
import it.unibz.inf.ontop.substitution.ImmutableSubstitution;
import it.unibz.inf.ontop.substitution.InjectiveVar2VarSubstitution;
import it.unibz.inf.ontop.substitution.SubstitutionFactory;
import it.unibz.inf.ontop.utils.CoreUtilsFactory;
import it.unibz.inf.ontop.utils.ImmutableCollectors;
import it.unibz.inf.ontop.utils.R2RMLIRISafeEncoder;
import it.unibz.inf.ontop.utils.VariableGenerator;
import org.apache.commons.rdf.api.RDF;
import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.Literal;
import org.eclipse.rdf4j.model.Value;
import org.eclipse.rdf4j.model.datatypes.XMLDatatypeUtil;
import org.eclipse.rdf4j.query.Binding;
import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.algebra.*;
import org.eclipse.rdf4j.query.algebra.Count;
import org.eclipse.rdf4j.query.parser.ParsedQuery;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

public class RDF4JInputQueryTranslatorImpl implements RDF4JInputQueryTranslator {

    private final CoreUtilsFactory coreUtilsFactory;
    private final TermFactory termFactory;
    private final SubstitutionFactory substitutionFactory;
    private final TypeFactory typeFactory;
    private final IntermediateQueryFactory iqFactory;
    private final AtomFactory atomFactory;
    private final RDF rdfFactory;
    private final FunctionSymbolFactory functionSymbolFactory;

    private static final Logger log = LoggerFactory.getLogger(RDF4JInputQueryTranslatorImpl.class);

    @Inject
    public RDF4JInputQueryTranslatorImpl(CoreUtilsFactory coreUtilsFactory, TermFactory termFactory, SubstitutionFactory substitutionFactory,
                                         TypeFactory typeFactory, IntermediateQueryFactory iqFactory, AtomFactory atomFactory, RDF rdfFactory,
                                         FunctionSymbolFactory functionSymbolFactory) {
        this.coreUtilsFactory = coreUtilsFactory;
        this.termFactory = termFactory;
        this.substitutionFactory = substitutionFactory;
        this.typeFactory = typeFactory;
        this.iqFactory = iqFactory;
        this.atomFactory = atomFactory;
        this.rdfFactory = rdfFactory;
        this.functionSymbolFactory = functionSymbolFactory;
    }

    @Override
    public IQ translate(ParsedQuery pq) throws OntopInvalidInputQueryException, OntopUnsupportedInputQueryException {

        log.debug("Parsed query:\n{}", pq.toString());

        IQTree tree = translate(pq.getTupleExpr()).iqTree;

        ImmutableSet<Variable> vars = tree.getVariables();

        // Assumption: the binding names in the parsed query are in the desired order
        ImmutableList<Variable> projectedVars = pq.getTupleExpr().getBindingNames().stream()
                .map(termFactory::getVariable)
                // filter out the extra bindings generated by the rdf4j API for constants
                .filter(vars::contains)
                .collect(ImmutableCollectors.toList());
        log.debug("IQTree (before normalization):\n{}", tree.toString());
        return iqFactory.createIQ(
                atomFactory.getDistinctVariableOnlyDataAtom(
                        atomFactory.getRDFAnswerPredicate(projectedVars.size()),
                        projectedVars
                ),
                tree
        ).normalizeForOptimization();
    }

    @Override
    public IQ translateAskQuery(ParsedQuery pq) throws OntopUnsupportedInputQueryException, OntopInvalidInputQueryException {

        log.debug("Parsed query:\n{}", pq.toString());

        IQTree tree = translate(pq.getTupleExpr()).iqTree;

        log.debug("IQTree (before normalization):\n{}", tree.toString());
        return iqFactory.createIQ(
                atomFactory.getDistinctVariableOnlyDataAtom(
                        atomFactory.getRDFAnswerPredicate(0),
                        ImmutableList.of()
                ),
                projectOutAllVars(tree)
        ).normalizeForOptimization();
    }

    private IQTree projectOutAllVars(IQTree tree) {
        if (tree.getRootNode() instanceof QueryModifierNode) {
            return iqFactory.createUnaryIQTree(
                    (UnaryOperatorNode) tree.getRootNode(),
                    projectOutAllVars(((UnaryIQTree) tree).getChild())
            );
        }
        return iqFactory.createUnaryIQTree(
                iqFactory.createConstructionNode(
                        ImmutableSet.of()
                ),
                tree
        );
    }

    private TranslationResult translate(TupleExpr node) throws OntopInvalidInputQueryException, OntopUnsupportedInputQueryException {

        if (node instanceof StatementPattern){
            StatementPattern stmt = (StatementPattern)node;
            if( stmt.getScope().equals(StatementPattern.Scope.NAMED_CONTEXTS) ){
                return translateQuadPattern(stmt); // Davide> Quad
            }
            else return translateTriplePattern((StatementPattern) node);
        }

        if (node instanceof Join)
            return translateJoinLikeNode((Join) node);

        if (node instanceof LeftJoin)
            return translateJoinLikeNode((LeftJoin) node);

        if (node instanceof Difference)
            return translateDifference((Difference) node);

        if (node instanceof Union)
            return translateUnion((Union) node);

        if (node instanceof Filter)
            return translateFilter((Filter) node);

        if (node instanceof Projection)
            return translateProjection((Projection) node);

        if (node instanceof Slice)
            return translateSlice((Slice) node);

        if (node instanceof Distinct)
            return translateDistinctOrReduced(node);

        if (node instanceof Reduced)
            return translateDistinctOrReduced(node);

        if (node instanceof SingletonSet)
            return translateSingletonSet();

        if (node instanceof Group)
            return translateAggregate((Group) node);

        if (node instanceof Extension)
            return translateExtension((Extension) node);

        if (node instanceof BindingSetAssignment)
            return translateBindingSetAssignment((BindingSetAssignment) node);

        if (node instanceof Order)
            return translateOrder((Order) node);

        throw new Sparql2IqConversionException("Unexpected SPARQL operator : " + node.toString());
    }

    private TranslationResult translateDifference(Difference diff) throws OntopInvalidInputQueryException, OntopUnsupportedInputQueryException {

        TranslationResult leftTranslation = translate(diff.getLeftArg());
        TranslationResult rightTranslation = translate(diff.getRightArg());

        ImmutableSet<Variable> leftVars = leftTranslation.iqTree.getVariables();
        ImmutableSet<Variable> sharedVars = rightTranslation.iqTree.getVariables().stream()
                .filter(v -> leftVars.contains(v))
                .collect(ImmutableCollectors.toSet());

        if (sharedVars.isEmpty()) {
            return leftTranslation;
        }

        VariableGenerator vGen = coreUtilsFactory.createVariableGenerator(
                Sets.union(
                        leftTranslation.iqTree.getKnownVariables(),
                        rightTranslation.iqTree.getKnownVariables()
                ));

        InjectiveVar2VarSubstitution sub = generateVariableSubstitution(sharedVars, vGen);

        ImmutableExpression ljCond = getLJConditionForDifference(
                sharedVars,
                sub,
                leftTranslation.nullableVariables,
                rightTranslation.nullableVariables
        );
        ImmutableExpression filter = getFilterConditionForDifference(sub);

        return new TranslationResult(
                iqFactory.createUnaryIQTree(
                        iqFactory.createFilterNode(
                                filter
                        ),
                        iqFactory.createBinaryNonCommutativeIQTree(
                                iqFactory.createLeftJoinNode(ljCond),
                                leftTranslation.iqTree,
                                rightTranslation.iqTree.applyDescendingSubstitutionWithoutOptimizing(sub)
                        )),
                leftTranslation.nullableVariables
        );
    }

    private ImmutableExpression getLJConditionForDifference(ImmutableSet<Variable> sharedVars, InjectiveVar2VarSubstitution sub,
                                                            ImmutableSet<Variable> leftNullableVars, ImmutableSet<Variable> rightNullableVars) {
        return getConjunction(
                Stream.concat(
                        sharedVars.stream()
                                .map(v -> getEqOrNullable(v, sub.get(v), leftNullableVars, rightNullableVars)),
                        Stream.of(
                                getDisjunction(
                                        sharedVars.stream()
                                                .map(v -> termFactory.getStrictEquality(v, sub.get(v)))
                                                .collect(ImmutableCollectors.toList())
                        ))).collect(ImmutableCollectors.toList())
        );
    }

    private ImmutableExpression getEqOrNullable(Variable leftVar, Variable renamedVar, ImmutableSet<Variable> leftNullableVars,
                                   ImmutableSet<Variable> rightNullableVars) {

        List<ImmutableExpression> disjuncts = new ArrayList<>();
        disjuncts.add(termFactory.getStrictEquality(
                leftVar,
                renamedVar
        ));
        if(leftNullableVars.contains(leftVar)){
            disjuncts.add(termFactory.getDBIsNull(leftVar));
        }
        if(rightNullableVars.contains(leftVar)){
            disjuncts.add(termFactory.getDBIsNull(renamedVar));
        }
        return getDisjunction(ImmutableList.copyOf(disjuncts));
    }


    private ImmutableExpression getFilterConditionForDifference(InjectiveVar2VarSubstitution sub) {
        return getConjunction(sub.getImmutableMap().values().stream()
                .map(v -> termFactory.getDBIsNull(v))
                .collect(ImmutableCollectors.toList())
        );
    }

    private ImmutableExpression getConjunction(ImmutableList<ImmutableExpression> expressions) {
        return expressions.size() == 1 ?
                expressions.iterator().next() :
                termFactory.getConjunction(expressions);
    }

    private ImmutableExpression getDisjunction(ImmutableList<ImmutableExpression> expressions) {
        return expressions.size() == 1 ?
                expressions.iterator().next() :
                termFactory.getDisjunction(expressions);
    }

    private TranslationResult translateAggregate(Group groupNode) throws OntopInvalidInputQueryException, OntopUnsupportedInputQueryException {
        TranslationResult child = translate(groupNode.getArg());
        AggregationNode an = getAggregationNode(groupNode, child.iqTree.getVariables());
        return new TranslationResult(
                iqFactory.createUnaryIQTree(
                        an,
                        child.iqTree
                ),
                getAggregateOutputNullableVars(
                        an,
                        child.nullableVariables
                ));
    }

    private ImmutableSet<Variable> getAggregateOutputNullableVars(AggregationNode an, ImmutableSet<Variable> childNullableVars) {
        return Stream.concat(
                an.getGroupingVariables().stream()
                        .filter(childNullableVars::contains),
                an.getSubstitution().getImmutableMap().entrySet().stream()
                        .filter(e -> e.getValue().getFunctionSymbol().isNullable(ImmutableSet.of(0)))
                        .map(Map.Entry::getKey)
        ).collect(ImmutableCollectors.toSet());

    }

    private AggregationNode getAggregationNode(Group groupNode, ImmutableSet<Variable> childVariables) {

        // Assumption: every variable used in a definition is itself defined either in the subtree of in a previous ExtensionElem
        ImmutableList<VarDef> varDefs = ImmutableList.copyOf(
                getGroupVarDefs(
                        groupNode.getGroupElements().iterator(),
                        new HashSet<>(childVariables)
                ));

        ImmutableList<ImmutableSubstitution> mergedVarDefs = mergeVarDefs(varDefs.iterator()).stream()
                .map(ImmutableMap::copyOf)
                .map(substitutionFactory::getSubstitution)
                .collect(ImmutableCollectors.toList());
        if (mergedVarDefs.size() > 1) {
            throw new Sparql2IqConversionException("Unexpected parsed SPARQL query: nested complex projections appear " +
                    "within an RDF4J Group node: " + groupNode);
        }
        return iqFactory.createAggregationNode(
                groupNode.getGroupBindingNames().stream()
                        .map(termFactory::getVariable)
                        .collect(ImmutableCollectors.toSet()),
                mergedVarDefs.iterator().next()
        );
    }

    private List<VarDef> getGroupVarDefs(Iterator<GroupElem> it, Set<Variable> allowedVars) {
        if (it.hasNext()) {
            GroupElem elem = it.next();
            ImmutableTerm term = getTerm(
                    elem.getOperator(),
                    allowedVars
            );
            Variable definedVar = termFactory.getVariable(elem.getName());
            allowedVars.add(definedVar);

            List<VarDef> varDefs = getGroupVarDefs(it, allowedVars);
            varDefs.add(
                    new VarDef(
                            definedVar,
                            term
                    ));
            return varDefs;
        }
        return new ArrayList<>();
    }

    private TranslationResult translateOrder(Order node) throws OntopInvalidInputQueryException, OntopUnsupportedInputQueryException {
        TranslationResult child = translate(node.getArg());
        ImmutableSet<Variable> variables = child.iqTree.getVariables();
        return new TranslationResult(
                iqFactory.createUnaryIQTree(
                        iqFactory.createOrderByNode(
                                node.getElements().stream()
                                        .map(o -> getOrderComparator(o, variables))
                                        .collect(ImmutableCollectors.toList())
                        ),
                        child.iqTree
                ),
                child.nullableVariables
        );
    }

    private OrderByNode.OrderComparator getOrderComparator(OrderElem oe, ImmutableSet<Variable> variables) {
        ImmutableTerm expr = getTerm(oe.getExpr(), variables);
        if (expr.isGround()) {
            throw new RuntimeException(
                    new OntopUnsupportedInputQueryException("The ordering criterion " + oe.getExpr() + "does not contain any variables"));
        }
        return iqFactory.createOrderComparator(
                (NonGroundTerm) expr,
                oe.isAscending()
        );
    }


    private TranslationResult translateBindingSetAssignment(BindingSetAssignment node) {

        Constant nullConstant = termFactory.getNullConstant();

        ImmutableSet<Variable> allVars = node.getBindingNames().stream()
                .map(termFactory::getVariable)
                .collect(ImmutableCollectors.toSet());

        ImmutableSet<ImmutableMap<Variable, ImmutableTerm>> maps = StreamSupport.stream(
                node.getBindingSets().spliterator(),
                false
        ).map(bs -> getBsMap(bs, nullConstant))
                .collect(ImmutableCollectors.toSet());

        ImmutableSet<Variable> nullableVars = maps.iterator().next().keySet().stream()
                .filter(v -> maps.stream().anyMatch(m -> m.get(v).equals(nullConstant)))
                .collect(ImmutableCollectors.toSet());

        ImmutableList<IQTree> subtrees = maps.stream()
                .map(substitutionFactory::getSubstitution)
                .map(sub -> iqFactory.createConstructionNode(
                        sub.getDomain(),
                        sub
                ))
                .map(cn -> iqFactory.createUnaryIQTree(
                        cn,
                        iqFactory.createTrueNode()
                ))
                .collect(ImmutableCollectors.toList());

        return new TranslationResult(
                subtrees.size() == 1 ?
                        subtrees.iterator().next() :
                        iqFactory.createNaryIQTree(
                                iqFactory.createUnionNode(allVars),
                                subtrees
                        ),
                nullableVars
        );
    }

    private ImmutableMap<Variable, ImmutableTerm> getBsMap(BindingSet bs, Constant nullConstant) {
        return bs.getBindingNames().stream()
                .collect(ImmutableCollectors.toMap(
                        termFactory::getVariable,
                        x -> getTermForBinding(
                                x,
                                bs,
                                nullConstant
                        )));
    }

    private ImmutableTerm getTermForBinding(String x, BindingSet bindingSet, Constant nullConstant) {
        Binding binding = bindingSet.getBinding(x);
        return binding == null
                ? nullConstant :
                getTermForLiteralOrIri(binding.getValue());
    }

    private TranslationResult translateSingletonSet() {
        return new TranslationResult(
                iqFactory.createTrueNode(),
                ImmutableSet.of()
        );
    }

    private TranslationResult translateDistinctOrReduced(TupleExpr genNode) throws OntopInvalidInputQueryException, OntopUnsupportedInputQueryException {
        TranslationResult child;
        if (genNode instanceof Distinct) {
            child = translate(((Distinct) genNode).getArg());
        } else if (genNode instanceof Reduced) {
            child = translate(((Reduced) genNode).getArg());
        } else {
            throw new Sparql2IqConversionException("Unexpected node type for node: " + genNode.toString());
        }
        return new TranslationResult(
                iqFactory.createUnaryIQTree(
                        iqFactory.createDistinctNode(),
                        child.iqTree
                ),
                child.nullableVariables
        );
    }

    private TranslationResult translateSlice(Slice node) throws OntopInvalidInputQueryException, OntopUnsupportedInputQueryException {
        TranslationResult child = translate(node.getArg());

        return new TranslationResult(
                iqFactory.createUnaryIQTree(
                        getSliceNode(node),
                        child.iqTree
                ),
                child.nullableVariables
        );
    }

    private SliceNode getSliceNode(Slice node) {
        // Assumption: at least the limit or the offset is not -1 (otherwise the rdf4j parser would not generate a slice node)
        long offset = node.getOffset() == -1 ?
                0 :
                node.getOffset();
        return node.getLimit() == -1 ?
                iqFactory.createSliceNode(offset) :
                iqFactory.createSliceNode(
                        offset,
                        node.getLimit()
                );
    }

    private TranslationResult translateFilter(Filter filter)
            throws OntopInvalidInputQueryException, OntopUnsupportedInputQueryException {

        TranslationResult child = translate(filter.getArg());
        return new TranslationResult(
                iqFactory.createUnaryIQTree(
                        iqFactory.createFilterNode(
                                getFilterExpression(
                                        filter.getCondition(),
                                        child.iqTree.getVariables()
                                )),
                        child.iqTree
                ),
                child.nullableVariables
        );
    }

    private TranslationResult translateJoinLikeNode(BinaryTupleOperator join) throws OntopInvalidInputQueryException, OntopUnsupportedInputQueryException {

        if (!(join instanceof Join) && !(join instanceof LeftJoin)) {
            throw new Sparql2IqConversionException("A left or inner join is expected");
        }
        TranslationResult leftTranslation = translate(join.getLeftArg());
        TranslationResult rightTranslation = translate(join.getRightArg());

        IQTree leftQuery = leftTranslation.iqTree;
        IQTree rightQuery = rightTranslation.iqTree;

        ImmutableSet<Variable> nullableFromLeft = leftTranslation.nullableVariables;
        ImmutableSet<Variable> nullableFromRight = rightTranslation.nullableVariables;

        ImmutableSet<Variable> projectedFromRight = rightTranslation.iqTree.getVariables();
        ImmutableSet<Variable> projectedFromLeft = leftTranslation.iqTree.getVariables();

        ImmutableSet<Variable> toCoalesce = projectedFromLeft.stream()
                .filter(projectedFromRight::contains)
                .filter(v -> nullableFromLeft.contains(v) || nullableFromRight.contains(v))
                .collect(ImmutableCollectors.toSet());

        VariableGenerator variableGenerator = coreUtilsFactory.createVariableGenerator(
                Sets.union(
                        leftQuery.getKnownVariables(),
                        rightQuery.getKnownVariables()
                )
        );
        // May update the variable generator!!
        InjectiveVar2VarSubstitution leftRenamingSubstitution = generateVariableSubstitution(toCoalesce, variableGenerator);
        InjectiveVar2VarSubstitution rightRenamingSubstitution = generateVariableSubstitution(toCoalesce, variableGenerator);

        ImmutableSubstitution<ImmutableTerm> topSubstitution = substitutionFactory.getSubstitution(toCoalesce.stream()
                .collect(ImmutableCollectors.toMap(
                        x -> x,
                        x -> termFactory.getImmutableFunctionalTerm(
                                functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.COALESCE, 2),
                                leftRenamingSubstitution.get(x),
                                rightRenamingSubstitution.get(x)
                        ))));

        Optional<ImmutableExpression> filterExpression = join instanceof LeftJoin ?
                getLeftJoinFilter(
                        (LeftJoin) join,
                        topSubstitution,
                        Sets.union(
                                projectedFromLeft,
                                projectedFromRight
                        ).immutableCopy()
                ) :
                Optional.empty();

        Optional<ImmutableExpression> joinCondition = generateJoinCondition(
                leftRenamingSubstitution,
                rightRenamingSubstitution,
                toCoalesce,
                filterExpression
        );

        JoinLikeNode joinLikeNode = join instanceof LeftJoin ?
                iqFactory.createLeftJoinNode(joinCondition) :
                iqFactory.createInnerJoinNode(joinCondition);

        ImmutableSet<Variable> sharedVars = Sets.intersection(
                leftQuery.getVariables(),
                rightQuery.getVariables()
        ).immutableCopy();

        ImmutableSet<Variable> nullableVarsUnion = Sets.union(
                nullableFromLeft,
                nullableFromRight
        ).immutableCopy();

        ImmutableSet<Variable> newNullableVars = join instanceof LeftJoin ?
                Sets.difference(
                        rightQuery.getVariables(),
                        sharedVars
                ).immutableCopy() :
                ImmutableSet.of();

        ImmutableSet<Variable> newSetOfNullableVars = join instanceof LeftJoin ?
                Sets.union(
                        nullableVarsUnion,
                        newNullableVars
                ).immutableCopy() :
                Sets.difference(
                        nullableVarsUnion,
                        sharedVars
                ).immutableCopy();

        IQTree joinQuery = buildJoinQuery(
                joinLikeNode,
                leftQuery,
                rightQuery,
                topSubstitution,
                leftRenamingSubstitution,
                rightRenamingSubstitution,
                toCoalesce
        );

        return new TranslationResult(joinQuery, newSetOfNullableVars);
    }

    private Optional<ImmutableExpression> getLeftJoinFilter(LeftJoin join, ImmutableSubstitution<ImmutableTerm> topSubstitution, ImmutableSet<Variable> variables) {
        return join.getCondition() != null ?
                Optional.of(
                        topSubstitution.applyToBooleanExpression(
                                getFilterExpression(
                                        join.getCondition(),
                                        variables
                                ))) :
                Optional.empty();
    }

    private InjectiveVar2VarSubstitution generateVariableSubstitution(
            ImmutableSet<Variable> domain, VariableGenerator variableGenerator) {

        return substitutionFactory.getInjectiveVar2VarSubstitution(domain.stream()
                .collect(ImmutableCollectors.toMap(
                        x -> x,
                        variableGenerator::generateNewVariableFromVar
                )));
    }

    private Optional<ImmutableExpression> generateJoinCondition(InjectiveVar2VarSubstitution leftRenamingSubstitution,
                                                                InjectiveVar2VarSubstitution rightRenamingSubstitution,
                                                                ImmutableSet<Variable> toCoalesce,
                                                                Optional<ImmutableExpression> filterCondition) {

        Optional<ImmutableExpression> compatibilityCondition = generateCompatibilityCondition(
                leftRenamingSubstitution,
                rightRenamingSubstitution,
                toCoalesce
        );
        return compatibilityCondition.isPresent() ?
                compatibilityCondition
                        .map(compatExpr -> filterCondition.map(
                                filterExpr -> termFactory.getConjunction(
                                        filterExpr,
                                        compatExpr
                                )).orElse(compatExpr)
                        ) :
                filterCondition;
    }

    private Optional<ImmutableExpression> generateCompatibilityCondition(
            InjectiveVar2VarSubstitution leftChildSubstitution,
            InjectiveVar2VarSubstitution rightChildSubstitution, ImmutableSet<Variable> toCoalesce) {

        return termFactory.getConjunction(toCoalesce.stream()
                .map(v -> generateCompatibleExpression(
                        v,
                        leftChildSubstitution,
                        rightChildSubstitution
                )));
    }

    private ImmutableExpression generateCompatibleExpression(Variable outputVariable,
                                                             InjectiveVar2VarSubstitution leftChildSubstitution,
                                                             InjectiveVar2VarSubstitution rightChildSubstitution) {

        ImmutableExpression isNullExpression;

        Variable leftVariable = leftChildSubstitution.applyToVariable(outputVariable);
        Variable rightVariable = rightChildSubstitution.applyToVariable(outputVariable);

        ImmutableExpression equalityCondition = termFactory.getStrictEquality(leftVariable, rightVariable);
        ImmutableExpression leftIsNull = termFactory.getDBIsNull(leftVariable);
        ImmutableExpression rightIsNull = termFactory.getDBIsNull(rightVariable);
        isNullExpression = termFactory.getDisjunction(leftIsNull, rightIsNull);
        return termFactory.getDisjunction(equalityCondition, isNullExpression);
    }

    private IQTree buildJoinQuery(JoinLikeNode joinNode,
                                  IQTree leftQuery,
                                  IQTree rightQuery,
                                  ImmutableSubstitution<ImmutableTerm> topSubstitution,
                                  InjectiveVar2VarSubstitution leftRenamingSubstitution,
                                  InjectiveVar2VarSubstitution rightRenamingSubstitution,
                                  ImmutableSet<Variable> toCoalesce) {

        ImmutableSet<Variable> projectedVariables = Stream.concat(
                Stream.concat(
                        leftQuery.getVariables().stream(),
                        rightQuery.getVariables().stream()
                ).filter(v -> !toCoalesce.contains(v)),
                topSubstitution.getImmutableMap().keySet().stream())
                .collect(ImmutableCollectors.toSet());

        IQTree joinTree = getJoinTree(
                joinNode,
                leftQuery.applyDescendingSubstitutionWithoutOptimizing(leftRenamingSubstitution),
                rightQuery.applyDescendingSubstitutionWithoutOptimizing(rightRenamingSubstitution)
        );

        return topSubstitution.isEmpty() ?
                joinTree :
                iqFactory.createUnaryIQTree(
                        iqFactory.createConstructionNode(
                                projectedVariables,
                                topSubstitution
                        ),
                        joinTree
                );
    }

    private IQTree getJoinTree(JoinLikeNode joinNode, IQTree leftTree, IQTree rightTree) {
        if (joinNode instanceof LeftJoinNode) {
            return iqFactory.createBinaryNonCommutativeIQTree(
                    (LeftJoinNode) joinNode,
                    leftTree,
                    rightTree
            );
        }
        if (joinNode instanceof InnerJoinNode) {
            return iqFactory.createNaryIQTree(
                    (InnerJoinNode) joinNode,
                    ImmutableList.of(
                            leftTree,
                            rightTree
                    ));
        }
        throw new Sparql2IqConversionException("Left or inner join expected");
    }

    private TranslationResult translateProjection(Projection node) throws OntopInvalidInputQueryException, OntopUnsupportedInputQueryException {
        TranslationResult child = translate(node.getArg());
        IQTree subQuery = child.iqTree;

        List<ProjectionElem> projectionElems = node.getProjectionElemList().getElements();

        ImmutableSubstitution<Variable> substitution =
                substitutionFactory.getSubstitution(projectionElems.stream()
                        .filter(pe -> !pe.getTargetName().equals(pe.getSourceName()))
                        .collect(ImmutableCollectors.toMap(
                                pe -> termFactory.getVariable(pe.getSourceName()),
                                pe -> termFactory.getVariable(pe.getTargetName())
                        )));

        ImmutableSet<Variable> projectedVars = projectionElems.stream()
                .map(pe -> termFactory.getVariable(pe.getTargetName()))
                .collect(ImmutableCollectors.toSet());

        if (substitution.isEmpty() && projectedVars.equals(child.iqTree.getVariables())) {
            return child;
        }

        subQuery = subQuery.applyDescendingSubstitutionWithoutOptimizing(substitution);
        projectedVars = projectionElems.stream()
                .map(pe -> termFactory.getVariable(pe.getTargetName()))
                .collect(ImmutableCollectors.toSet());
        ImmutableSet<Variable> subQueryVariables = subQuery.getVariables();

        // Substitution for possibly unbound variables
        ImmutableSubstitution<ImmutableTerm> newSubstitution = substitutionFactory.getSubstitution(projectedVars.stream()
                .filter(v -> !subQueryVariables.contains(v))
                .collect(ImmutableCollectors.toMap(
                        v -> v,
                        v -> termFactory.getNullConstant())));

        ConstructionNode projectNode = iqFactory.createConstructionNode(projectedVars, newSubstitution);
        return new TranslationResult(
                iqFactory.createUnaryIQTree(
                        projectNode,
                        subQuery
                ),
                child.nullableVariables.stream()
                        .map(substitution::applyToVariable)
                        .filter(t -> t instanceof Variable)
                        .map(t -> (Variable) t)
                        .collect(ImmutableCollectors.toSet())
        );
    }

    private TranslationResult translateUnion(Union union) throws OntopInvalidInputQueryException, OntopUnsupportedInputQueryException {
        TranslationResult leftTranslation = translate(union.getLeftArg());
        TranslationResult rightTranslation = translate(union.getRightArg());

        IQTree leftQuery = leftTranslation.iqTree;
        IQTree rightQuery = rightTranslation.iqTree;

        ImmutableSet<Variable> nullableFromLeft = leftTranslation.nullableVariables;
        ImmutableSet<Variable> nullableFromRight = rightTranslation.nullableVariables;

        ImmutableSet<Variable> leftVariables = leftQuery.getVariables();
        ImmutableSet<Variable> rightVariables = rightQuery.getVariables();

        ImmutableSet<Variable> nullOnLeft = Sets.difference(rightVariables, leftVariables).immutableCopy();
        ImmutableSet<Variable> nullOnRight = Sets.difference(leftVariables, rightVariables).immutableCopy();

        ImmutableSet<Variable> allNullable = Sets.union(nullableFromLeft, Sets.union(nullableFromRight, Sets.union(nullOnLeft, nullOnRight))).immutableCopy();

        ImmutableSet<Variable> rootVariables = Sets.union(leftVariables, rightVariables).immutableCopy();

        ImmutableSubstitution<ImmutableTerm> leftSubstitution = substitutionFactory.getSubstitution(nullOnLeft.stream()
                .collect(ImmutableCollectors.toMap(
                        x -> x,
                        x -> termFactory.getNullConstant()
                )));

        ImmutableSubstitution<ImmutableTerm> rightSubstitution = substitutionFactory.getSubstitution(nullOnRight.stream()
                .collect(ImmutableCollectors.toMap(
                        x -> x,
                        x -> termFactory.getNullConstant()
                )));

        ConstructionNode leftCn = iqFactory.createConstructionNode(rootVariables, leftSubstitution);
        ConstructionNode rightCn = iqFactory.createConstructionNode(rootVariables, rightSubstitution);

        UnionNode unionNode = iqFactory.createUnionNode(rootVariables);

        ConstructionNode rootNode = iqFactory.createConstructionNode(rootVariables);

        return new TranslationResult(
                iqFactory.createUnaryIQTree(
                        rootNode,
                        iqFactory.createNaryIQTree(
                                unionNode,
                                ImmutableList.of(
                                        iqFactory.createUnaryIQTree(
                                                leftCn,
                                                leftQuery
                                        ),
                                        iqFactory.createUnaryIQTree(
                                                rightCn,
                                                rightQuery
                                        )))),
                allNullable
        );
    }

    private TranslationResult translateTriplePattern(StatementPattern triple) {

        return new TranslationResult(
                iqFactory.createIntensionalDataNode(
                        atomFactory.getIntensionalTripleAtom(
                                translateRDF4JVar(triple.getSubjectVar(), ImmutableSet.of(), true),
                                translateRDF4JVar(triple.getPredicateVar(), ImmutableSet.of(), true),
                                translateRDF4JVar(triple.getObjectVar(), ImmutableSet.of(), true)
                        )),
                ImmutableSet.of()
        );
    }

    // Davide> Quads support
    private TranslationResult translateQuadPattern(StatementPattern quad) {

        return new TranslationResult(
                iqFactory.createIntensionalDataNode(
                        atomFactory.getIntensionalQuadAtom(
                                translateRDF4JVar(quad.getSubjectVar(), ImmutableSet.of(), true),
                                translateRDF4JVar(quad.getPredicateVar(), ImmutableSet.of(), true),
                                translateRDF4JVar(quad.getObjectVar(), ImmutableSet.of(), true),
                                translateRDF4JVar(quad.getContextVar(), ImmutableSet.of(), true)
                        )),
                ImmutableSet.of()
        );
    }

    private TranslationResult translateExtension(Extension node) throws OntopInvalidInputQueryException, OntopUnsupportedInputQueryException {
        TranslationResult childTranslation = translate(node.getArg());
        IQTree childQuery = childTranslation.iqTree;

        // Warning: an ExtensionElement might reference a variable appearing in a previous ExtensionElement
        // So we may need to nest them

        // Assumption: every variable used in a definition is itself defined either in the subtree of in a previous ExtensionElem
        ImmutableList<VarDef> varDefs = ImmutableList.copyOf(
                getVarDefs(
                        node.getElements().iterator(),
                        new HashSet<>(childQuery.getVariables())
                ));
        ImmutableSet<Variable> childVars = childQuery.getVariables();
        varDefs = varDefs.stream()
                .filter(vd -> !childVars.contains(vd.var))
                .collect(ImmutableCollectors.toList());
        if (varDefs.isEmpty()) {
            return childTranslation;
        }
        ImmutableList<ImmutableSubstitution> mergedVarDefs = mergeVarDefs(varDefs.iterator()).stream()
                .map(ImmutableMap::copyOf)
                .map(substitutionFactory::getSubstitution)
                .collect(ImmutableCollectors.toList());

        return translateExtensionElems(
                mergedVarDefs.reverse().iterator(),
                childTranslation
        );
    }

    private List<VarDef> getVarDefs(Iterator<ExtensionElem> it, Set<Variable> allowedVars) {
        if (it.hasNext()) {
            ExtensionElem elem = it.next();
            if (elem.getExpr() instanceof Var && elem.getName().equals(((Var) elem.getExpr()).getName())) {
                return getVarDefs(it, allowedVars);
            }
            ImmutableTerm term = getTerm(
                    elem.getExpr(),
                    allowedVars
            );
            Variable definedVar = termFactory.getVariable(elem.getName());
            allowedVars.add(definedVar);

            List<VarDef> varDefs = getVarDefs(it, allowedVars);
            varDefs.add(
                    new VarDef(
                            definedVar,
                            term
                    ));
            return varDefs;
        }
        return new ArrayList<>();
    }

    private TranslationResult translateExtensionElems(UnmodifiableIterator<ImmutableSubstitution> it, TranslationResult subquery) {
        if (it.hasNext()) {
            ImmutableSubstitution sub = it.next();
            TranslationResult child = translateExtensionElems(it, subquery);
            ImmutableSet<Variable> newNullableVariables = getNewNullableVars(sub.getImmutableMap(), child.nullableVariables);
            return new TranslationResult(
                    iqFactory.createUnaryIQTree(
                            iqFactory.createConstructionNode(
                                    Sets.union(
                                            child.iqTree.getVariables(),
                                            sub.getDomain()
                                    ).immutableCopy(),
                                    sub
                            ),
                            child.iqTree
                    ),
                    Sets.union(
                            child.nullableVariables,
                            newNullableVariables
                    ).immutableCopy()
            );
        }

        return new TranslationResult(
                subquery.iqTree,
                subquery.nullableVariables
        );
    }

    private ImmutableSet<Variable> getNewNullableVars(ImmutableMap<Variable, ImmutableTerm> sub, ImmutableSet<Variable> nullableVariables) {
        return sub.entrySet().stream()
                .filter(e -> e.getValue().getVariableStream()
                        .anyMatch(nullableVariables::contains))
                .map(Map.Entry::getKey)
                .collect(ImmutableCollectors.toSet());
    }

    private List<HashMap<Variable, ImmutableTerm>> mergeVarDefs(UnmodifiableIterator<VarDef> it) {
        if (it.hasNext()) {
            VarDef varDef = it.next();
            List<HashMap<Variable, ImmutableTerm>> subs = mergeVarDefs(it);
            HashMap<Variable, ImmutableTerm> currentsub = subs.get(subs.size() - 1);
            if (varDef.term.getVariableStream()
                    .anyMatch(currentsub::containsKey)) {
                HashMap<Variable, ImmutableTerm> map = new HashMap<>();
                map.put(varDef.var, varDef.term);
                subs.add(map);
                return subs;
            }
            currentsub.put(
                    varDef.var,
                    varDef.term
            );
            return subs;
        }
        List<HashMap<Variable, ImmutableTerm>> list = new ArrayList<>();
        list.add(new HashMap<>());
        return list;
    }

    private GroundTerm getTermForLiteralOrIri(Value v) {

        if (v instanceof Literal) {
            try {
                return getTermForLiteral((Literal) v);
            } catch (OntopUnsupportedInputQueryException e) {
                throw new RuntimeException(e);
            }
        }
        if (v instanceof IRI)
            return getTermForIri((IRI) v);

        throw new RuntimeException(new OntopUnsupportedInputQueryException("The value " + v + " is not supported yet!"));
    }

    private GroundTerm getTermForLiteral(Literal literal) throws OntopUnsupportedInputQueryException {
        IRI typeURI = literal.getDatatype();
        String value = literal.getLabel();
        Optional<String> lang = literal.getLanguage();

        if (lang.isPresent()) {
            return termFactory.getRDFLiteralConstant(value, lang.get());

        } else {
            RDFDatatype type;
            /*
             * default data type is xsd:string
             */
            if (typeURI == null) {
                type = typeFactory.getXsdStringDatatype();
            } else {
                type = typeFactory.getDatatype(rdfFactory.createIRI(typeURI.stringValue()));
            }

            if (type == null)
                // ROMAN (27 June 2016): type1 in open-eq-05 test would not be supported in OWL
                // the actual value is LOST here
                return termFactory.getConstantIRI(rdfFactory.createIRI(typeURI.stringValue()));
            // old strict version:
            // throw new RuntimeException("Unsupported datatype: " + typeURI);

            // BC-march-19: it seems that SPARQL does not forbid invalid lexical forms
            //     (e.g. when interpreted as an EBV, they evaluate to false)
            // However, it is unclear in which cases it would be interesting to offer a (partial) robustness to
            // such errors coming from the input query
            // check if the value is (lexically) correct for the specified datatype
            if (!XMLDatatypeUtil.isValidValue(value, typeURI))
                throw new OntopUnsupportedInputQueryException(
                        String.format("Invalid lexical forms are not accepted. Found for %s: %s", type.toString(), value));

            return termFactory.getRDFLiteralConstant(value, type);
        }
    }

    /**
     * @param expr      expression
     * @param variables the set of variables that can occur in the expression
     *                  (the rest will be replaced with NULL)
     */

    private ImmutableExpression getFilterExpression(ValueExpr expr, ImmutableSet<Variable> variables) {

        ImmutableTerm term = getTerm(expr, variables);

        ImmutableTerm xsdBooleanTerm = term.inferType()
                .flatMap(TermTypeInference::getTermType)
                .filter(t -> t instanceof RDFDatatype)
                .filter(t -> ((RDFDatatype) t).isA(XSD.BOOLEAN))
                .isPresent()
                ? term
                : termFactory.getSPARQLEffectiveBooleanValue(term);

        return termFactory.getRDF2DBBooleanFunctionalTerm(xsdBooleanTerm);
    }

    /**
     * @param expr           expression
     * @param knownVariables the set of variables that can occur in the expression
     *                       (the rest will be replaced with NULL)
     * @return term
     */

    private ImmutableTerm getTerm(ValueExpr expr, Set<Variable> knownVariables) {

        // PrimaryExpression ::= BrackettedExpression | BuiltInCall | iriOrFunction |
        //                          RDFLiteral | NumericLiteral | BooleanLiteral | Var
        // iriOrFunction ::= iri ArgList?

        if (expr instanceof Var)
            return translateRDF4JVar((Var) expr, knownVariables, false);
        if (expr instanceof ValueConstant) {
            Value v = ((ValueConstant) expr).getValue();
            return getTermForLiteralOrIri(v);
        }
        if (expr instanceof Bound) {
            // BOUND (Sec 17.4.1.1)
            // xsd:boolean  BOUND (variable var)
            Var v = ((Bound) expr).getArg();
            Variable var = termFactory.getVariable(v.getName());
            return knownVariables.contains(var) ?
                    termFactory.getImmutableFunctionalTerm(
                            functionSymbolFactory.getRequiredSPARQLFunctionSymbol(
                                    SPARQL.BOUND,
                                    1
                            ),
                            var
                    ) :
                    termFactory.getRDFLiteralConstant("false", XSD.BOOLEAN);
        }
        if (expr instanceof UnaryValueOperator) {
            // O-ary count
            if (expr instanceof Count && ((Count) expr).getArg() == null) {
                return termFactory.getImmutableFunctionalTerm(
                        functionSymbolFactory.getRequiredSPARQLFunctionSymbol(
                                SPARQL.COUNT,
                                0
                        ));
            }

            ImmutableTerm term = getTerm(((UnaryValueOperator) expr).getArg(), knownVariables);

            //Unary count
            if (expr instanceof Count) {
                Count count = (Count) expr;
                if (count.isDistinct())
                    return termFactory.getImmutableFunctionalTerm(
                            functionSymbolFactory.getRequiredSPARQLDistinctAggregateFunctionSymbol(SPARQL.COUNT,1),
                            term
                    );
                return termFactory.getImmutableFunctionalTerm(
                        functionSymbolFactory.getRequiredSPARQLFunctionSymbol(
                                SPARQL.COUNT,
                                1
                        ),
                        term
                );
            }
            if (expr instanceof Avg) {
                return termFactory.getImmutableFunctionalTerm(
                        functionSymbolFactory.getRequiredSPARQLFunctionSymbol(
                                SPARQL.AVG,
                                1
                        ),
                        term
                );
            }
            if (expr instanceof Sum) {
                return termFactory.getImmutableFunctionalTerm(
                        functionSymbolFactory.getRequiredSPARQLFunctionSymbol(
                                SPARQL.SUM,
                                1
                        ),
                        term
                );
            }
            if (expr instanceof Min) {
                return termFactory.getImmutableFunctionalTerm(
                        functionSymbolFactory.getRequiredSPARQLFunctionSymbol(
                                SPARQL.MIN,
                                1
                        ),
                        term
                );
            }
            if (expr instanceof Max) {
                return termFactory.getImmutableFunctionalTerm(
                        functionSymbolFactory.getRequiredSPARQLFunctionSymbol(
                                SPARQL.MAX,
                                1
                        ),
                        term
                );
            }
            if (expr instanceof Sample) {
                return termFactory.getImmutableFunctionalTerm(
                        functionSymbolFactory.getRequiredSPARQLFunctionSymbol(
                                SPARQL.SAMPLE,
                                1
                        ),
                        term
                );
            }
            if (expr instanceof GroupConcat) {
                ValueExpr sep = ((GroupConcat) expr).getSeparator();
                return sep == null ?
                        termFactory.getImmutableFunctionalTerm(
                                functionSymbolFactory.getRequiredSPARQLFunctionSymbol(
                                        SPARQL.GROUP_CONCAT,
                                        1
                                ),
                                term
                        ) :
                        termFactory.getImmutableFunctionalTerm(
                                functionSymbolFactory.getRequiredSPARQLFunctionSymbol(
                                        SPARQL.GROUP_CONCAT,
                                        2
                                ),
                                term,
                                getTerm(
                                        sep,
                                        ImmutableSet.of()
                                ));
            }
            if (expr instanceof Not) {
                return termFactory.getImmutableFunctionalTerm(
                        functionSymbolFactory.getRequiredSPARQLFunctionSymbol(XPathFunction.NOT.getIRIString(), 1),
                        convertToXsdBooleanTerm(term));
            }
            if (expr instanceof IsNumeric) {
                return termFactory.getImmutableFunctionalTerm(
                        functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.IS_NUMERIC, 1),
                        term);
            }
            if (expr instanceof IsLiteral) {
                return termFactory.getImmutableFunctionalTerm(
                        functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.IS_LITERAL, 1),
                        term);
            }
            if (expr instanceof IsURI) {
                return termFactory.getImmutableFunctionalTerm(
                        functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.IS_IRI, 1),
                        term);
            }
            if (expr instanceof Str) {
                return termFactory.getImmutableFunctionalTerm(
                        functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.STR, 1),
                        term);
            }
            if (expr instanceof Datatype) {
                return termFactory.getImmutableFunctionalTerm(
                        functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.DATATYPE, 1),
                        term);
            }
            if (expr instanceof IsBNode) {
                return termFactory.getImmutableFunctionalTerm(
                        functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.IS_BLANK, 1),
                        term);
            }
            if (expr instanceof Lang) {
                ValueExpr arg = ((UnaryValueOperator) expr).getArg();
                if (arg instanceof Var)
                    return termFactory.getImmutableFunctionalTerm(
                            functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.LANG, 1),
                            term);
                throw new RuntimeException(new OntopUnsupportedInputQueryException("A variable or a value is expected in " + expr));
            }
            // other subclasses
            // IRIFunction: IRI (Sec 17.4.2.8) for constructing IRIs
            // IsNumeric:  isNumeric (Sec 17.4.2.4) for checking whether the argument is a numeric value
            // AggregateOperatorBase: Avg, Min, Max, etc.
            // Like:  ??
            // IsResource: ??
            // LocalName: ??
            // Namespace: ??
            // Label: ??
        }
        if (expr instanceof BinaryValueOperator) {
            BinaryValueOperator bexpr = (BinaryValueOperator) expr;
            ImmutableTerm term1 = getTerm(bexpr.getLeftArg(), knownVariables);
            ImmutableTerm term2 = getTerm(bexpr.getRightArg(), knownVariables);

            if (expr instanceof And) {
                return termFactory.getImmutableFunctionalTerm(
                        functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.LOGICAL_AND, 2),
                        convertToXsdBooleanTerm(term1), convertToXsdBooleanTerm(term2));
            }
            if (expr instanceof Or) {
                return termFactory.getImmutableFunctionalTerm(
                        functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.LOGICAL_OR, 2),
                        convertToXsdBooleanTerm(term1), convertToXsdBooleanTerm(term2));
            }
            if (expr instanceof SameTerm) {
                // sameTerm (Sec 17.4.1.8)
                // Corresponds to the STRICT equality (same lexical value, same type)
                return termFactory.getImmutableFunctionalTerm(
                        functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.SAME_TERM, 2),
                        term1, term2);
            }
            if (expr instanceof Regex) {
                // REGEX (Sec 17.4.3.14)
                // xsd:boolean  REGEX (string literal text, simple literal pattern)
                // xsd:boolean  REGEX (string literal text, simple literal pattern, simple literal flags)
                Regex reg = (Regex) expr;
                return (reg.getFlagsArg() != null)
                        ? termFactory.getImmutableFunctionalTerm(
                        functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.REGEX, 3),
                        term1, term2,
                        getTerm(reg.getFlagsArg(), knownVariables))
                        : termFactory.getImmutableFunctionalTerm(
                        functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.REGEX, 2),
                        term1, term2);
            }
            if (expr instanceof Compare) {
                final SPARQLFunctionSymbol p;

                switch (((Compare) expr).getOperator()) {
                    case NE:
                        return termFactory.getImmutableFunctionalTerm(
                                functionSymbolFactory.getRequiredSPARQLFunctionSymbol(XPathFunction.NOT.getIRIString(), 1),
                                termFactory.getImmutableFunctionalTerm(
                                        functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.EQ, 2),
                                        term1, term2));
                    case EQ:
                        p = functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.EQ, 2);
                        break;
                    case LT:
                        p = functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.LESS_THAN, 2);
                        break;
                    case LE:
                        return termFactory.getImmutableFunctionalTerm(
                                functionSymbolFactory.getRequiredSPARQLFunctionSymbol(XPathFunction.NOT.getIRIString(), 1),
                                termFactory.getImmutableFunctionalTerm(
                                        functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.GREATER_THAN, 2),
                                        term1, term2));
                    case GE:
                        return termFactory.getImmutableFunctionalTerm(
                                functionSymbolFactory.getRequiredSPARQLFunctionSymbol(XPathFunction.NOT.getIRIString(), 1),
                                termFactory.getImmutableFunctionalTerm(
                                        functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.LESS_THAN, 2),
                                        term1, term2));
                    case GT:
                        p = functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.GREATER_THAN, 2);
                        break;
                    default:
                        throw new RuntimeException(new OntopUnsupportedInputQueryException("Unsupported operator: " + expr));
                }
                return termFactory.getImmutableFunctionalTerm(p, term1, term2);
            }
            if (expr instanceof MathExpr) {
                SPARQLFunctionSymbol f = functionSymbolFactory.getRequiredSPARQLFunctionSymbol(
                        NumericalOperations.get(((MathExpr) expr).getOperator()), 2);
                return termFactory.getImmutableFunctionalTerm(f, term1, term2);
            }
            /*
             * Restriction: the first argument must be LANG(...) and the second  a constant
             * (for guaranteeing that the langMatches logic is not delegated to the native query)
             */
            if (expr instanceof LangMatches) {
                if (!(term1 instanceof ImmutableFunctionalTerm
                        && ((ImmutableFunctionalTerm) term1).getFunctionSymbol() instanceof LangSPARQLFunctionSymbol)
                        || !(term2 instanceof RDFConstant)) {
                    throw new RuntimeException(new OntopUnsupportedInputQueryException("The function langMatches is " +
                            "only supported with lang(..) function for the first argument and a constant for the second")
                    );
                }

                SPARQLFunctionSymbol langMatchesFunctionSymbol = functionSymbolFactory.getRequiredSPARQLFunctionSymbol(SPARQL.LANG_MATCHES, 2);

                return termFactory.getImmutableFunctionalTerm(langMatchesFunctionSymbol, term1, term2);
            }
        }
        if (expr instanceof FunctionCall) {
            FunctionCall f = (FunctionCall) expr;

            ImmutableList<ImmutableTerm> terms = f.getArgs().stream()
                    .map(a -> getTerm(a, knownVariables))
                    .collect(ImmutableCollectors.toList());

            String functionName = extractFunctionName(f.getURI());

            Optional<SPARQLFunctionSymbol> optionalFunctionSymbol = functionSymbolFactory.getSPARQLFunctionSymbol(
                    functionName, terms.size());

            if (optionalFunctionSymbol.isPresent()) {
                return termFactory.getImmutableFunctionalTerm(optionalFunctionSymbol.get(), terms);
            }
        }
        if (expr instanceof NAryValueOperator) {
            NAryValueOperator op = (NAryValueOperator) expr;

            ImmutableList<ImmutableTerm> terms = op.getArguments().stream()
                    .map(a -> getTerm(a, knownVariables))
                    .collect(ImmutableCollectors.toList());

            if (expr instanceof Coalesce) {
                SPARQLFunctionSymbol functionSymbol = functionSymbolFactory.getRequiredSPARQLFunctionSymbol(
                        SPARQL.COALESCE, terms.size());
                return termFactory.getImmutableFunctionalTerm(functionSymbol, terms);
            }
            //Others: ListMemberOperator
        }
        // other subclasses
        // SubQueryValueOperator
        // If
        // BNodeGenerator
        throw new RuntimeException(new OntopUnsupportedInputQueryException("The expression " + expr + " is not supported yet!"));
    }

    /**
     * Changes some function names when RDF4J abuses the SPARQL standard (i.e. is too tightly-coupled)
     *
     * The typical example is the YEAR() function which is replaced by RDF4J by fn:year-from-dateTime because
     * the SPARQL 1.1 specification has only consider the case of xsd:dateTime, not xsd:date.
     * Obviously, all the major implementations also support the case of xsd:date and use the fun:year-from-date when
     * appropriated.
     *
     * This method reverses fn:year-from-dateTime into YEAR, as it now maps to a function symbol that accepts
     * both xsd:date and xsd:dateTime.
     *
     */
    private String extractFunctionName(String uri) {

        if (uri.equals(XPathFunction.YEAR_FROM_DATETIME.getIRIString()))
            return SPARQL.YEAR;
        else if (uri.equals(XPathFunction.MONTH_FROM_DATETIME.getIRIString()))
            return SPARQL.MONTH;
        else if (uri.equals(XPathFunction.DAY_FROM_DATETIME.getIRIString()))
            return SPARQL.DAY;
        else
            return uri;
    }


    /**
     * Translates a RDF4J "Var" (which can be a variable or a constant) into a Ontop term.
     */
    private VariableOrGroundTerm translateRDF4JVar(Var v, Set<Variable> subtreeVariables, boolean leafNode) {
        // If this "Var" is a constant
        if ((v.hasValue()))
            return getTermForLiteralOrIri(v.getValue());
        // Otherwise, this "Var" is a variable
        Variable var = termFactory.getVariable(v.getName());
        // If the subtree is empty, create a variable
        if (leafNode)
            return var;
        // Otherwise, check whether the variable is projected
        return subtreeVariables.contains(var) ?
                var :
                termFactory.getNullConstant();
    }

    /**
     * @param v URI object
     * @return term (URI template)
     */
    private GroundTerm getTermForIri(IRI v) {
        return termFactory.getConstantIRI(rdfFactory.createIRI(v.stringValue()));
    }


    private ImmutableTerm convertToXsdBooleanTerm(ImmutableTerm term) {

        return term.inferType()
                .flatMap(TermTypeInference::getTermType)
                .filter(t -> t instanceof RDFDatatype)
                .filter(t -> ((RDFDatatype) t).isA(XSD.BOOLEAN))
                .isPresent() ?
                term :
                termFactory.getSPARQLEffectiveBooleanValue(term);
    }

    private static final ImmutableMap<MathExpr.MathOp, String> NumericalOperations =
            new ImmutableMap.Builder<MathExpr.MathOp, String>()
                    .put(MathExpr.MathOp.PLUS, SPARQL.NUMERIC_ADD)
                    .put(MathExpr.MathOp.MINUS, SPARQL.NUMERIC_SUBSTRACT)
                    .put(MathExpr.MathOp.MULTIPLY, SPARQL.NUMERIC_MULTIPLY)
                    .put(MathExpr.MathOp.DIVIDE, SPARQL.NUMERIC_DIVIDE)
                    .build();

    private static class TranslationResult {
        final IQTree iqTree;
        final ImmutableSet<Variable> nullableVariables;

        TranslationResult(IQTree iqTree, ImmutableSet<Variable> nullableVariables) {
            this.nullableVariables = nullableVariables;
            this.iqTree = iqTree;
        }
    }

    private static class Sparql2IqConversionException extends OntopInternalBugException {

        Sparql2IqConversionException(String s) {
            super(s);
        }
    }

    private class VarDef {
        final Variable var;
        private final ImmutableTerm term;

        private VarDef(Variable var, ImmutableTerm term) {
            this.var = var;
            this.term = term;
        }
    }
}
