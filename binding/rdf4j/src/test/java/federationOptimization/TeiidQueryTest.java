package federationOptimization;

import com.google.common.base.Charsets;
import com.google.common.base.Throwables;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableMultimap;
import com.google.common.io.Resources;
import com.google.inject.Injector;
import it.unibz.inf.ontop.answering.logging.QueryLogger;
import it.unibz.inf.ontop.answering.reformulation.QueryReformulator;
import it.unibz.inf.ontop.answering.reformulation.impl.QuestQueryProcessor;
import it.unibz.inf.ontop.evaluator.QueryContext;
import it.unibz.inf.ontop.injection.CoreSingletons;
import it.unibz.inf.ontop.injection.IntermediateQueryFactory;
import it.unibz.inf.ontop.injection.OntopSQLOWLAPIConfiguration;
import it.unibz.inf.ontop.iq.IQ;
import it.unibz.inf.ontop.iq.node.impl.NativeNodeImpl;
import it.unibz.inf.ontop.iq.optimizer.FederationOptimizer;
import it.unibz.inf.ontop.iq.optimizer.impl.FederationOptimizerImpl;
import it.unibz.inf.ontop.model.atom.AtomFactory;
import it.unibz.inf.ontop.model.term.TermFactory;
import it.unibz.inf.ontop.query.KGQuery;
import it.unibz.inf.ontop.query.KGQueryFactory;
import org.junit.Test;
import org.junit.experimental.categories.Category;

import java.io.IOException;
import java.io.Reader;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.sql.*;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.stream.StreamSupport;

@Category(ObdfTest.class)
public class TeiidQueryTest {

    private static final String PLACEHOLDER_TEXT = "83376";

    private static final List<String> PLACEHOLDER_VALUES = ImmutableList.of(
            "171571", "177740", "20555", "37265", "37683", "42704", "67037", "69148", "123317", "184093",
            "188746", "30051", "32756", "50712", "53784", "64196", "72023", "83376", "85434", "121150");

    @Test
    public void testSqlExecution() throws Throwable {
        Map<String, String> sqlQueries = loadQueries("teiid-test.sql", PLACEHOLDER_TEXT, PLACEHOLDER_VALUES);
        executeSqlQueries(sqlQueries);
    }

    @Test
    public void testSparqlExecution() throws Throwable {
        FederationReformulator reformulator = createTeiidReformulator();
        Map<String, String> sparqlQueries = loadQueries("teiid-test.sparql", PLACEHOLDER_TEXT, PLACEHOLDER_VALUES);
        Map<String, String> sqlQueries = sparqlQueries.entrySet().stream()
                .collect(ImmutableMap.toImmutableMap(Map.Entry::getKey, e -> reformulator.reformulate(e.getValue())));
        executeSqlQueries(sqlQueries);
    }

    @Test
    public void testReformulation() throws Throwable {
        String sparqlQuery = Resources.toString(TeiidQueryTest.class.getResource("/federation/teiid-test.sparql"), Charsets.UTF_8);
        FederationReformulator reformulator = createTeiidReformulator();
        String sqlQuery = reformulator.reformulate(sparqlQuery);
        System.out.println(sqlQuery);
    }

    @SuppressWarnings("SameParameterValue")
    private static Map<String, String> loadQueries(String resource, String placeholderText, Iterable<String> placeholderValues) throws IOException {
        String template = Resources.toString(TeiidQueryTest.class.getResource("/federation/" + resource), Charsets.UTF_8);
        return StreamSupport
                .stream(placeholderValues.spliterator(), false)
                .collect(ImmutableMap.toImmutableMap(
                        v -> v,
                        v -> template.replace(placeholderText, v)));
    }

    /**
     * Run the supplied SQL queries, reporting on the number of results for each one and displaying the query plan
     * generated by Teiid for the last query execution.
     */
    private static void executeSqlQueries(Map<String, String> sqlQueries) throws Throwable {

        // Load Teiid connection properties from resource file
        Properties properties = new Properties();
        try (Reader in = Files.newBufferedReader(Paths.get("src/test/resources/federation/system-teiid-hom.properties"))) {
            properties.load(in);
        }
        String jdbcUrl = properties.getProperty("jdbc.url");
        String jdbcUser = properties.getProperty("jdbc.user");
        String jdbcPassword = properties.getProperty("jdbc.password");

        // Connect to Teiid to run queries
        Class.forName("org.teiid.jdbc.TeiidDriver");
        try (Connection conn = DriverManager.getConnection(jdbcUrl, jdbcUser, jdbcPassword)) {
            try (Statement stmt = conn.createStatement()) {

                // Enable logging of Teiid execution plans
                stmt.execute("SET SHOWPLAN ON");

                // Execute all queries, logging the number of results
                for (Map.Entry<String, String> e : sqlQueries.entrySet()) {
                    String id = e.getKey();
                    String sqlQuery = e.getValue();
                    try (ResultSet rs = stmt.executeQuery(sqlQuery)) {
                        int count = 0;
                        while (rs.next()) {
                            ++count;
                        }
                        System.out.println(count + " -- " + id);
                    }
                }

                // Display the query plan for the last query executed
                try (ResultSet rs = stmt.executeQuery("SHOW PLAN")) {
                    rs.next();
                    Clob clob = rs.getClob(1);
                    System.out.println(clob.getSubString(1, (int) clob.length()));
                }
            }
        }
    }

    private static FederationReformulator createTeiidReformulator() {
        return new FederationReformulator(
                "src/test/resources/federation/ontology.owl",
                "src/test/resources/federation/mappings.fed.teiid.obda",
                "src/test/resources/federation/system-teiid-hom.properties",
                null,
                "src/test/resources/federation/constraints.fed.txt",
                true,
                "src/test/resources/federation/source_relations.txt",
                "src/test/resources/federation/source_efficiency_labels.hom.txt",
                "src/test/resources/federation/hints.teiid-opt.txt"
        );
    }

    private static final class FederationReformulator {

        private final KGQueryFactory kgQueryFactory;
        private final QueryReformulator reformulator;
        private final FederationOptimizer federationOptimizer;

        public FederationReformulator(
                String owlFile,
                String obdaFile,
                String propertyFile,
                String metadataFile,
                String constraintFile,
                boolean optimizationEnabled,
                String sourceFile,
                String effLabelFile,
                String hintFile
        ) {
            try {
                // Create Ontop Configuration object
                OntopSQLOWLAPIConfiguration.Builder<?> builder = OntopSQLOWLAPIConfiguration
                        .defaultBuilder().ontologyFile(owlFile)
                        .basicImplicitConstraintFile(constraintFile)
                        .nativeOntopMappingFile(obdaFile)
                        .propertyFile(propertyFile)
                        .enableTestMode();
                if (metadataFile != null) {
                    builder = builder.dbMetadataFile(metadataFile);
                }
                OntopSQLOWLAPIConfiguration configuration = builder.build();

                // Initialize Ontop components' dependencies
                Injector injector = configuration.getInjector();
                IntermediateQueryFactory iqFactory = injector.getInstance(IntermediateQueryFactory.class);
                AtomFactory atomFactory = injector.getInstance(AtomFactory.class);
                TermFactory termFactory = injector.getInstance(TermFactory.class);
                CoreSingletons coreSingletons = injector.getInstance(CoreSingletons.class);

                // Initialize main Ontop components required for query reformulation
                this.kgQueryFactory = configuration.getKGQueryFactory();
                this.reformulator = configuration.loadQueryReformulator();
                this.federationOptimizer = new FederationOptimizerImpl(iqFactory, atomFactory, termFactory,
                        coreSingletons, optimizationEnabled, sourceFile, effLabelFile, hintFile);

            } catch (Throwable ex) {
                // Wrap if necessary and propagate
                Throwables.throwIfUnchecked(ex);
                throw new RuntimeException(ex);
            }
        }

        public String reformulate(String sparqlQuery) {
            try {
                // Perform all the steps necessary to reformulate the SPARQL query into SQL
                KGQuery<?> query = kgQueryFactory.createSPARQLQuery(sparqlQuery);
                QueryLogger queryLogger = reformulator.getQueryLoggerFactory().create(ImmutableMultimap.of());
                QueryContext emptyQueryContext = reformulator.getQueryContextFactory().create(ImmutableMap.of());
                QuestQueryProcessor.returnPlannedQuery = true;
                IQ inputIQ = reformulator.reformulateIntoNativeQuery(query, emptyQueryContext, queryLogger);
                QuestQueryProcessor.returnPlannedQuery = false;
                IQ optimizedIQ = federationOptimizer.optimize(inputIQ);
                IQ executableIQ = reformulator.generateExecutableQuery(optimizedIQ);
                return ((NativeNodeImpl) executableIQ.getTree().getChildren().get(0)).getNativeQueryString();

            } catch (Throwable ex) {
                // Wrap if necessary and propagate
                Throwables.throwIfUnchecked(ex);
                throw new RuntimeException(ex);
            }
        }

    }

}
